<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />

  <title>Class: Plotter</title>

  <link rel="stylesheet" href="./rdoc.css" type="text/css" media="screen" />

  <script src="./js/jquery.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="./js/thickbox-compressed.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="./js/quicksearch.js" type="text/javascript"
    charset="utf-8"></script>
  <script src="./js/darkfish.js" type="text/javascript"
    charset="utf-8"></script>

</head>
<body class="class">

  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="./index.html">Home</a>
          <a href="./index.html#classes">Classes</a>
          <a href="./index.html#methods">Methods</a>
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul>
          
            <li><a href="./lib/rplot_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/rplot.rb">lib/rplot.rb</a></li>
          
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">

      <!-- Parent Class -->
      
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link">Rplot</p>
        
      </div>
      

      <!-- Namespace Contents -->
      

      <!-- Method Quickref -->
      
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-draw">::draw</a></li>
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-c-params">::params</a></li>
          
          <li><a href="#method-i-alabel">#alabel</a></li>
          
          <li><a href="#method-i-arc">#arc</a></li>
          
          <li><a href="#method-i-bezier2">#bezier2</a></li>
          
          <li><a href="#method-i-bezier3">#bezier3</a></li>
          
          <li><a href="#method-i-bgcolor">#bgcolor</a></li>
          
          <li><a href="#method-i-box">#box</a></li>
          
          <li><a href="#method-i-capmod">#capmod</a></li>
          
          <li><a href="#method-i-circle">#circle</a></li>
          
          <li><a href="#method-i-close">#close</a></li>
          
          <li><a href="#method-i-color">#color</a></li>
          
          <li><a href="#method-i-concat">#concat</a></li>
          
          <li><a href="#method-i-cont">#cont</a></li>
          
          <li><a href="#method-i-delete">#delete</a></li>
          
          <li><a href="#method-i-draw">#draw</a></li>
          
          <li><a href="#method-i-ellarc">#ellarc</a></li>
          
          <li><a href="#method-i-ellipse">#ellipse</a></li>
          
          <li><a href="#method-i-endpath">#endpath</a></li>
          
          <li><a href="#method-i-erase">#erase</a></li>
          
          <li><a href="#method-i-fillcolor">#fillcolor</a></li>
          
          <li><a href="#method-i-fillmod">#fillmod</a></li>
          
          <li><a href="#method-i-filltype">#filltype</a></li>
          
          <li><a href="#method-i-flush">#flush</a></li>
          
          <li><a href="#method-i-fmiterlimit">#fmiterlimit</a></li>
          
          <li><a href="#method-i-fontname">#fontname</a></li>
          
          <li><a href="#method-i-fontsize">#fontsize</a></li>
          
          <li><a href="#method-i-havecap">#havecap</a></li>
          
          <li><a href="#method-i-joinmod">#joinmod</a></li>
          
          <li><a href="#method-i-label">#label</a></li>
          
          <li><a href="#method-i-labelwidth">#labelwidth</a></li>
          
          <li><a href="#method-i-line">#line</a></li>
          
          <li><a href="#method-i-linedash">#linedash</a></li>
          
          <li><a href="#method-i-linemod">#linemod</a></li>
          
          <li><a href="#method-i-linewidth">#linewidth</a></li>
          
          <li><a href="#method-i-marker">#marker</a></li>
          
          <li><a href="#method-i-move">#move</a></li>
          
          <li><a href="#method-i-open">#open</a></li>
          
          <li><a href="#method-i-pencolor">#pencolor</a></li>
          
          <li><a href="#method-i-point">#point</a></li>
          
          <li><a href="#method-i-restorestate">#restorestate</a></li>
          
          <li><a href="#method-i-rotate">#rotate</a></li>
          
          <li><a href="#method-i-savestate">#savestate</a></li>
          
          <li><a href="#method-i-scale">#scale</a></li>
          
          <li><a href="#method-i-space">#space</a></li>
          
          <li><a href="#method-i-space2">#space2</a></li>
          
          <li><a href="#method-i-textangle">#textangle</a></li>
          
          <li><a href="#method-i-translate">#translate</a></li>
          
        </ul>
      </div>
      

      <!-- Included Modules -->
      
    </div>

    <div id="project-metadata">
      
      
      <div id="fileindex-section" class="section project-section">
        <h3 class="section-header">Files</h3>
        <ul>
        
          <li class="file"><a href="./Gemfile.html">Gemfile</a></li>
        
          <li class="file"><a href="./LICENSE.html">LICENSE</a></li>
        
          <li class="file"><a href="./README_rdoc.html">README.rdoc</a></li>
        
          <li class="file"><a href="./Rakefile.html">Rakefile</a></li>
        
        </ul>
      </div>
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="./images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
        
          <li><a href="./Plotter.html">Plotter</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div>

  <div id="documentation">
    <h1 class="class">Plotter</h1>

    <div id="description">
      
<p>The graphical objects that libplot can draw include paths, circles and
ellipses, points, markers, and <em>adjusted labels</em> (justified text
strings). A path is a sequence of line segments, circular arcs, elliptic
arcs, quadratic Bezier curves, and/or cubic Bezier curves. Paths may be
open or closed. User-specified filling of paths, circles, and ellipses is
supported (fill rule and fill color, as well as pen color, may be
specified).  There is support for maintaining a Postscript-style stack of
graphics contexts, i.e., a stack of drawing attribute sets. Path-related
attributes include line thickness, line type, cap type, and join type, and
text-related attributes include font name, font size, and text angle.</p>

<p>The fundamental abstraction provided is that of a <a
href="Plotter.html">Plotter</a>. A <a href="Plotter.html">Plotter</a> is an
object with an interface for the drawing of vector graphics which is
similar to the interface provided by a traditional pen plotter. There are
many types of <a href="Plotter.html">Plotter</a>, which differ in the
output format they produce. Any number of Plotters, of the same or
different types, may exist simultaneously in an application.</p>

<p>The drawing operations supported by Plotters of different types are
identical, in agreement with the principle of device independence. So a
graphics application that is linked with libplot may easily be written so
as to produce output in any or all of the supported output formats.</p>

<p>The following are the currently supported types of Plotter:</p>
<dl><dt>X Plotters</dt>
<dd>
<p>An X <a href="Plotter.html">Plotter</a>, when opened, pops up a window on
an X Window System display and draws graphics in it. The window will be
<em>spun off</em> when the <a href="Plotter.html">Plotter</a> is closed; if
it is subsequently reopened, a new window will be popped up. A spun-off
window will remain on the screen but will vanish if you type <tt>q</tt> or
click your mouse in it. Future releases may permit X Plotters, when
reopened, to reuse an existing window.</p>
</dd><dt>X Drawable Plotters</dt>
<dd>
<p>An X Drawable <a href="Plotter.html">Plotter</a> draws graphics in one or
two specified drawables associated with an X Window System display. A
<em>drawable</em> is either a window or a pixmap.</p>
</dd><dt>PNM Plotters</dt>
<dd>
<p>A PNM <a href="Plotter.html">Plotter</a> produces a single page of output
in <em>portable anymap</em> format, and directs it to a file or other
specified output stream. There are three types of portable anymap: PBM
(portable bitmap, for monochrome graphics), PGM (portable graymap), and PPM
(portable pixmap, for colored graphics).  The output file will be in
whichever of these three formats is most appropriate. The file may be
viewed or edited with many applications, such as the free image display
application xv.</p>
</dd><dt>GIF Plotters</dt>
<dd>
<p>A GIF <a href="Plotter.html">Plotter</a> produces a single page of output
in a pseudo-GIF format. Unlike true GIF format, the pseudo-GIF format does
not use LZW compression: it uses run-length encoding instead. So it does
not transgress the Unisys patent that restricts the use of LZW compression.
However, the output file may be viewed or edited with any application that
understands GIF format, such as xv. The creation of animated pseudo-GIFs is
supported.</p>
</dd><dt>Illustrator Plotters</dt>
<dd>
<p>An Illustrator <a href="Plotter.html">Plotter</a> produces a single page of
output in the format used by Adobe Illustrator, and directs it to a file or
other specified output stream.  The file may be edited with Adobe
Illustrator (version 5, and more recent versions), or other applications.</p>
</dd><dt>Postscript Plotters</dt>
<dd>
<p>A Postscript <a href="Plotter.html">Plotter</a> produces Postscript output
and directs it to a file or other specified output stream.  If only a
single page of graphics is drawn on the <a href="Plotter.html">Plotter</a>
then its output is in EPS (encapsulated Postscript) format, so it may be
included in another document. It may also be edited with the idraw drawing
editor.</p>
</dd><dt>Fig Plotters</dt>
<dd>
<p>A Fig <a href="Plotter.html">Plotter</a> produces a single page of output
in Fig format and directs it to a file or other specified output stream.
The output may be edited with the xfig drawing editor. The xfig editor will
export drawings in various other formats for inclusion in documents.</p>
</dd><dt>PCL Plotters</dt>
<dd>
<p>A PCL <a href="Plotter.html">Plotter</a> produces output in PCL 5 format
and directs it to a file or other specified output stream. PCL 5 is a
powerful version of Hewlett–Packard’s Printer Control Language, which
supports vector graphics. The output may be sent to a PCL 5 device such as
a LaserJet printer or high-end inkjet.</p>
</dd><dt>HP-GL Plotters</dt>
<dd>
<p>An HP-GL <a href="Plotter.html">Plotter</a> produces output in the
Hewlett–Packard Graphics Language (by default, in HP-GL/2), and directs it
to a file or other specified output stream. The output may be imported into
another application, or sent to a plotter.</p>
</dd><dt>Tektronix Plotters</dt>
<dd>
<p>A Tektronix <a href="Plotter.html">Plotter</a> produces output in Tektronix
4014 format and directs it to a file or other specified output stream. The
output may be displayed on any Tektronix 4014 emulator. Such an emulator is
built into xterm, the X Window System terminal emulation program. The
MS-DOS version of kermit also includes such an emulator.</p>
</dd><dt>Metafile Plotters</dt>
<dd>
<p>A Metafile <a href="Plotter.html">Plotter</a> produces output in GNU
graphics metafile format and directs it to a file or other specified output
stream. This format is an extended version of the <em>plot(5)</em> format
found on some other operating systems.</p>
</dd></dl>

<p>A distinction among these types of <a href="Plotter.html">Plotter</a> is
that all except X and X Drawable Plotters write graphics to a file or other
output stream. An X <a href="Plotter.html">Plotter</a> pops up its own
windows, and an X Drawable <a href="Plotter.html">Plotter</a> draws
graphics in one or two X drawables.</p>

<p>Another distinction is that the first four types of <a
href="Plotter.html">Plotter</a> (X, X Drawable, PNM, and GIF) produce
bitmap output, while the remaining types produce output in a vector
graphics format. In bitmap output the structure of the graphical objects is
lost, but in a vector format it is retained.</p>

<p>An additional distinction is that X, X Drawable, Tektronix and Metafile
Plotters are real-time. This means that they draw graphics or write to an
output stream as the drawing operations are invoked on them. The remaining
types of <a href="Plotter.html">Plotter</a> are not real-time, since their
output streams can only be emitted after all functions have been called.
For PNM and GIF Plotters, this is because the bitmap must be constructed
before it is written out. For Illustrator and Postscript Plotters, it is
because a <em>bounding box</em> line must be placed at the head of the
output file. For a Fig <a href="Plotter.html">Plotter</a>, it is because
color definitions must be placed at the head of the output file.</p>

<p>The most important operations supported by any <a
href="Plotter.html">Plotter</a> are <tt>open</tt> and <tt>close</tt>, which
open and close it. Graphics may be drawn, and drawing attributes set, only
within an <tt>open</tt>…<tt>close</tt> pair or as block passed to
<tt>draw</tt> method. The graphics produced within each
<tt>open</tt>…<tt>close</tt> pair constitute a <em>page</em>. In principle,
any <a href="Plotter.html">Plotter</a> may be opened and closed arbitrarily
many times. An X <a href="Plotter.html">Plotter</a> displays each page in a
separate X window, and Postscript, PCL, and HP-GL Plotters render each page
as a separate physical page. X Drawable Plotters and Tektronix Plotters
manipulate a single drawable or display, on which pages are displayed in
succession. Plotters that do not draw in real time (PNM, GIF, Illustrator,
Postscript, Fig, PCL, and HP-GL Plotters) may wait until their existence
comes to an end (i.e., until they are deleted) before outputting their
pages of graphics.</p>

<p>In the current release of libplot, Postscript Plotters delay outputting
graphics in this way, but PCL and HP-GL Plotters output each page of
graphics individually, i.e., when closepl is invoked. PNM, GIF, Illustrator
and Fig Plotters are similar, but output only the first page. That is
because PNM, GIF, Illustrator and Fig formats support only a single page of
graphics.</p>

<p>There are several other basic operations which any <a
href="Plotter.html">Plotter</a> supports. The <em>graphics display</em>
drawn in by a <a href="Plotter.html">Plotter</a> is a square or rectangular
region on a display device. But when using any <a
href="Plotter.html">Plotter</a> to draw graphics, a user will specify the
coordinates of graphical objects in device-independent <em>user
coordinates</em>, rather than in device coordinates. A <a
href="Plotter.html">Plotter</a> relates the user coordinate system to the
device coordinate system by performing an affine transformation, which must
be specified by the user.</p>

<p>Immediately after invoking <tt>open</tt> to open a <a
href="Plotter.html">Plotter</a>, an application should invoke the
<tt>space</tt> operation to initialize this transformation. This invocation
specifies the rectangular region (in user coordinates) that will be mapped
by the <a href="Plotter.html">Plotter</a> to the graphics display. The
affine transformation may be updated at any later time by invoking
<tt>space</tt> again, or by invoking <tt>concat</tt>. The <tt>concat</tt>
method will <em>concatenate</em> (i.e., compose) the current affine
transformation with any specified affine transformation. This sort of
concatenation is a capability familiar from, e.g., Postscript.</p>

<p>Each <a href="Plotter.html">Plotter</a> maintains a Postscript-style stack
of graphics contexts. This makes possible the rapid, efficient drawing of
complicated pages of graphics.  A graphics context includes the current
affine transformation from the user coordinate system to the device
coordinate system. It also includes such modal drawing attributes as
graphics cursor position, linemode, line thickness, pen and fill colors,
and the font used for drawing text. The state of any uncompleted path (if
any) is included as well, since paths may be drawn incrementally, one
portion (line segment or arc) at a time. The current graphics context is
pushed onto the stack by calling <tt>savestate</tt>, and popped off by
calling <tt>restorestate</tt>.</p>

<p>To permit vector graphics animation, any page of graphics may be split into
<em>frames</em>. A frame is ended, and a new frame is begun, by invoking
the <tt>erase</tt> method. On a <a href="Plotter.html">Plotter</a> that
does real-time plotting (i.e., an X, X Drawable, Tektronix, or Metafile <a
href="Plotter.html">Plotter</a>), this erases all plotted objects from the
graphics display, allowing a new frame to be drawn. Displaying a sequence
of frames in succession creates the illusion of smooth animation.</p>

<p>On most Plotters that do not do real-time plotting (i.e., PNM, Illustrator,
Postscript, Fig, PCL, or HP-GL Plotters), invoking <tt>erase</tt> deletes
all plotted objects from an internal buffer. For this reason, most Plotters
that do not do real-time plotting will display only the final frame of any
multiframe page.</p>

<p>GIF Plotters are in a class by themselves. Even though they do not do real
time plotting, a GIF <a href="Plotter.html">Plotter</a> can produce
multi-image output, i.e., an animated pseudo-GIF file, from a multiframe
page. As noted above, the pseudo-GIF file produced by a GIF <a
href="Plotter.html">Plotter</a> will contain only the first page of
graphics. But if this page consists of multiple frames, then each
invocation of erase, after the first, will be treated by default as a
separator between successive images.</p>

    </div>

    <!-- Constants -->
    

    <!-- Attributes -->
    

    <!-- Methods -->
    
    <div id="public-class-method-details" class="method-section section">
      <h3 class="section-header">Public Class Methods</h3>

    
      <div id="draw-method" class="method-detail ">
        <a name="method-c-draw"></a>

        
        <div class="method-heading">
          <span class="method-name">draw</span><span
            class="method-args">(type, out_path, in_path = nil, err_path = nil)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Create a new plotter that live inside the <tt>block</tt> passed to
<tt>draw</tt>.  Operations in <tt>block</tt> are wrapped between
<tt>open</tt>, <tt>erase</tt> and <tt>delete</tt> methods.</p>
          

          
          <div class="method-source-code"
            id="draw-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 605</span>
def self.draw(type, out_path, in_path = nil, err_path = nil)
  plotter = <span class="ruby-constant">Plotter</span>.new(type, out_path, in_path, err_path)
  plotter.open
  plotter.erase
  yield(plotter)
  plotter.delete
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="new-method" class="method-detail ">
        <a name="method-c-new"></a>

        
        <div class="method-heading">
          <span class="method-name">new</span><span
            class="method-args">(type, out_path, in_path = nil, err_path = nil)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Creates a <a href="Plotter.html">Plotter</a> of type <tt>type</tt>, where
<tt>type</tt> may be <em>X</em>, <em>Xdrawable</em>, <em>pnm</em>,
<em>gif</em>, <em>ai</em>, <em>ps</em>, <em>fig</em>, <em>pcl</em>,
<em>hpgl</em>, <em>tek</em>, or <em>meta</em>.  The <a
href="Plotter.html">Plotter</a> will have input path <tt>in_path</tt>,
output path <tt>out_path</tt>, and error path <tt>err_path</tt>. Any or all
of these three may be <tt>nil</tt>. Currently, all Plotters are write-only,
so <tt>in_path</tt> is ignored. X Plotters and X Drawable Plotters write
graphics to an X Window System display rather than to an output stream, so
if <tt>type</tt> is <em>X</em> or <em>Xdrawable</em> then <tt>out_path</tt>
is ignored as well. Error messages (if any) are written to the stream
created with <tt>err_path</tt>, unless <tt>err_path</tt> is <tt>nil</tt>.</p>

<p><tt>OpenPlotterError</tt> exception will be raise if the <a
href="Plotter.html">Plotter</a> could not be create.</p>
          

          
          <div class="method-source-code"
            id="new-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 233</span>
def initialize(type, out_path, in_path = nil, err_path = nil)
  super(type, in_path, out_path, err_path)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="params-method" class="method-detail ">
        <a name="method-c-params"></a>

        
        <div class="method-heading">
          <span class="method-name">params</span><span
            class="method-args">(options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Sets the value of the device driver parameters. The parameter values in
effect at the time any <a href="Plotter.html">Plotter</a> is created are
copied into it.  Unrecognized parameters are ignored.</p>

<p>The list of the recognized parameters:</p>
<dl><dt>DISPLAY</dt>
<dd>
<p>(Default <tt>nil</tt>.) The X Window System display on which the graphics
display will be popped up, as an X window. This is relevant only to X
Plotters.</p>
</dd><dt>BITMAPSIZE</dt>
<dd>
<p>(Default “570x570”.) The size of the graphics display in terms of pixels.
This is relevant only to X Plotters, PNM Plotters, and GIF Plotters. For X
Plotters, the value of this parameter will automatically, if it is not set,
be taken from the X resource Xplot.geometry. This is for backward
compatibility.</p>
</dd><dt>PAGESIZE</dt>
<dd>
<p>(Default “letter”.) The size of the page on which the graphics display will
be positioned. This is relevant only to Illustrator, Postscript, Fig, PCL,
and HP-GL Plotters. “letter” means an 8.5in by 11in page. Any ISO page size
in the range “a0”…“a4” or ANSI page size in the range “a”…“e” may be
specified (“letter” is an alias for “a” and “tabloid” is an alias for “b”).
“legal”, “ledger”, and “b5” are recognized page sizes also. For Illustrator
and Postscript Plotters, the graphics display will be a square region
centered on the specified page and occupying its full width, with allowance
being made for margins. For Fig Plotters, the graphics display will be a
square region of the same size, positioned in the upper left corner of an
xfig display. For PCL and HP-GL Plotters, the graphics display will be a
square region of the same size, but may be positioned differently. For PCL
Plotters, fine control over its positioning on the page may be accomplished
by setting the PCL_XOFFSET and PCL_YOFFSET parameters. For HP-GL Plotters,
<tt>HPGL_XOFFSET</tt> and <tt>HPGL_YOFFSET</tt> are used similarly.</p>
</dd><dt>BG_COLOR</dt>
<dd>
<p>(Default “white”.) The initial background color of the graphics display,
when drawing each page of graphics. This is relevant to X Plotters, PNM
Plotters, GIF Plotters, and X Drawable Plotters (for the last, the
background color shows up only if erase is invoked). The background color
may be changed at any later time by invoking the bgcolor (or bgcolorname)
and erase operations.  An unrecognized color name sets the background color
to the default.</p>
</dd><dt>GIF_ANIMATION</dt>
<dd>
<p>(Default “yes”.) Relevant only to GIF Plotters. “yes” means that the erase
operation will have special semantics: with the exception of its first
invocation, it will act as a separator between successive images in the
written-out pseudo-GIF file. “no” means that erase should act as it does on
other Plotters that do not write graphics in real time, i.e., it should
erase the image under construction by filling it with the background color.
If “no” is specified, the pseudo-GIF file will contain only a single image.</p>
</dd><dt>GIF_DELAY</dt>
<dd>
<p>(Default “0”.) Relevant only to GIF Plotters. The delay, in hundredths of a
second, after each image in a written-out animated pseudo-GIF file. The
value should be an integer in the range “0”…“65535”.</p>
</dd><dt>GIF_ITERATIONS</dt>
<dd>
<p>(Default “0”.) Relevant only to GIF Plotters. The number of times that an
animated pseudo-GIF file should be <em>looped</em>. The value should be an
integer in the range “0”…“65535”.</p>
</dd><dt>HPGL_ASSIGN_COLORS</dt>
<dd>
<p>(Default “no”.) Relevant only to HP-GL Plotters, and only if the value of
<tt>HPGL_VERSION</tt> is “2”. “no” means to draw with a fixed set of pens,
specified by setting the <tt>HPGL_PENS</tt> parameter. “yes” means that pen
colors will not restricted to the palette specified in <tt>HPGL_PENS</tt>:
colors will be assigned to <em>logical pens</em> in the range #1…#31, as
needed. Other than color LaserJet printers and DesignJet plotters, not many
HP-GL/2 devices allow the assignment of colors to logical pens. So this
parameter should be used with caution.</p>
</dd><dt>HPGL_OPAQUE_MODE</dt>
<dd>
<p>(Default “yes”.) Relevant only to HP-GL Plotters, and only if the value of
HPGL_VERSION is “2”. “yes” means that the HP-GL/2 output device should be
switched into opaque mode, rather than transparent mode. This allows
objects to be filled with opaque white and other opaque colors. It also
allows the drawing of visible white lines, which by convention are drawn
with pen #0. Not all HP-GL/2 devices support opaque mode or the use of pen
#0 to draw visible white lines. In particular, HP-GL/2 pen plotters do not.
Some older HP-GL/2 devices reportedly malfunction if asked to switch into
opaque mode. If the output of an HP-GL <a href="Plotter.html">Plotter</a>
is to be sent to such a device, a “no” value is recommended.</p>
</dd><dt>HPGL_PENS</dt>
<dd>
<p>(Default “+1=black:2=red:3=green:4=yellow:5=blue:6=magenta:7=cyan+” if the
value of <tt>HPGL_VERSION</tt> is “1.5” or “2” and “1=black” if the value
of HPGL_VERSION is “1”). Relevant only to HP-GL Plotters. The set of
available pens; the format should be self-explanatory. The color for any
pen in the range #1…#31 may be specified. For information on what color
names are recognized, see section Specifying Colors by Name. Pen #1 must
always be present, though it need not be black. Any other pen in the range
#1…#31 may be omitted.</p>
</dd><dt>HPGL_ROTATE</dt>
<dd>
<p>(Default “0”.) Relevant only to HP-GL Plotters. The angle, in degrees, by
which the graphics display should be rotated on the page relative to the
default orientation. Recognized values are “0”, “90”, “180”, and “270”;
“no” and “yes” are equivalent to “0” and “90” respectively. This parameter
is provided to facilitate switching between portrait and landscape
orientations. For HP-GL devices this is frequently a concern, since some
HP-GL devices (<em>plotters</em>) draw with a default landscape
orientation, and others (<em>printers</em>) draw with a default portrait
orientation. “180” and “270” are supported only if <tt>HPGL_VERSION</tt> is
“2”.</p>
</dd><dt>HPGL_VERSION</dt>
<dd>
<p>(Default “2”.) Relevant only to HP-GL Plotters. “1” means that the output
should be generic HP-GL, “1.5” means that the output should be suitable for
the HP7550A graphics plotter and the HP758x, HP7595A and HP7596A drafting
plotters (HP-GL with some HP-GL/2 extensions), and “2” means that the
output should be modern HP-GL/2. If the version is less than “2” then the
only available fonts will be vector fonts, and all paths will be drawn with
a default thickness, so that invoking capmod, joinmod, and fmiterlimit will
have no effect. Also, the <em>nonzero winding number rule</em> will not be
supported when filling paths, so invoking fillmod will have no effect.
Additionally, if the version is “1” then the filling of arbitrary paths
will not be supported (circles and rectangles aligned with the coordinate
axes may be filled, however).</p>
</dd><dt>HPGL_XOFFSET, HPGL_YOFFSET</dt>
<dd>
<p>(Defaults “0.0cm” and “0.0cm”.) Relevant only to HP-GL Plotters.
Adjustments, in the x and y directions, of the position of the graphics
display on the page. They may be specified in centimeters, millimeters, or
inches. For example, an offset could be specified as “2cm” or “1.2in”.</p>
</dd><dt>INTERLACE</dt>
<dd>
<p>(Default “no”.) Relevant only to GIF Plotters. If the value is “yes”, the
pseudo-GIF output file will be interlaced. That means that it will be
displayed in an interlaced (nonlinear) way by many applications.</p>
</dd><dt>MAX_LINE_LENGTH</dt>
<dd>
<p>(Default “500”.) The maximum number of points that a path may contain,
before it is flushed to the display device.  If this flushing occurs, the
path will be split into two or more sub-paths, though the splitting should
not be noticeable. Splitting will not be performed if the path is filled.
This parameter is relevant to all Plotters except Tektronix and Metafile
Plotters. The reason for splitting long paths is that some display devices
(e.g., old Postscript printers and HP-GL pen plotters) have limited buffer
sizes. It is not relevant to Tektronix or Metafile Plotters, since they
draw paths in real time and have no buffer limitations.</p>
</dd><dt>META_PORTABLE</dt>
<dd>
<p>(Default “no”.) Relevant only to Metafile Plotters. “yes” means that the
output should be in a portable (human-readable) version of the metafile
format, rather than the default (binary) version. See section The Graphics
Metafile Format.</p>
</dd><dt>PCL_ASSIGN_COLORS</dt>
<dd>
<p>(Default “no”.) Relevant only to PCL Plotters. “no” means to draw with a
fixed set of pens. “yes” means that pen colors will not restricted to this
palette: colors will be assigned to <em>logical pens</em>, as needed. Other
than color LaserJet printers, not many PCL 5 devices allow the assignment
of colors to logical pens. So this parameter should be used with caution.</p>
</dd><dt>PCL_BEZIERS</dt>
<dd>
<p>(Default “yes”.) Relevant only to PCL Plotters. “yes” means that when
drawing Bezier curves, the special <em>Bezier instructions</em> will be
used. “no” means that these instructions will not be used. Instead, each
Bezier curve will be approximated and drawn as a polygonal line. Other than
the LaserJet III, which was Hewlett–Packard’s first PCL 5 printer, all
Hewlett–Packard’s PCL 5 printers support the Bezier instructions.</p>
</dd><dt>PCL_ROTATE</dt>
<dd>
<p>(Default “0”.) Relevant only to PCL Plotters. The angle, in degrees, by
which the graphics display should be rotated on the page relative to the
default orientation. Recognized values are “0”, “90”, “180”, and “270”;
“no” and “yes” are equivalent to “0” and “90” respectively. This parameter
is provided to facilitate switching between portrait and landscape
orientations. For PCL 5 devices this is frequently a concern, since some
PCL 5 devices (<em>plotters</em>) draw with a default landscape
orientation, and others (<em>printers</em>) draw with a default portrait
orientation.</p>
</dd><dt>PCL_XOFFSET, PCL_YOFFSET</dt>
<dd>
<p>(Defaults “0.0cm” and “0.0cm”.) Relevant only to PCL Plotters. Adjustments,
in the x and y directions, of the position of the graphics display on the
page. They may be specified in centimeters, millimeters, or inches. For
example, an offset could be specified as “2cm” or “1.2in”.</p>
</dd><dt>PNM_PORTABLE</dt>
<dd>
<p>(Default “no”.) Relevant only to PNM Plotters. “yes” means that the output
should be in a portable (human-readable) version of PBM/PGM/PPM format,
rather than the default (binary) version. `Portable’ is something of a
misnomer, since binary PBM/PGM/PPM files are also portable, in the sense
that they are machine-independent.</p>
</dd><dt>TERM</dt>
<dd>
<p>(Default <tt>nil</tt>.) Relevant only to Tektronix Plotters. If the value
is <em>xterm</em>, <em>xterms</em>, or <em>kterm</em>, it is taken as a
sign that the current application is running in an X Window System VT100
terminal emulator: an xterm. Before drawing graphics, a Tektronix <a
href="Plotter.html">Plotter</a> will emit an escape sequence that causes
the terminal emulator’s auxiliary Tektronix window, which is normally
hidden, to pop up. After the graphics are drawn, an escape sequence that
returns control to the original VT100 window will be emitted. The Tektronix
window will remain on the screen. If the value is <em>kermit</em>,
<em>ansi.sys</em>, <em>ansissys</em>, <em>ansi.sysk</em>, or
<em>ansisysk</em>, it is taken as a sign that the current application is
running in the VT100 terminal emulator provided by the MS-DOS version of
kermit. Before drawing graphics, a Tektronix <a
href="Plotter.html">Plotter</a> will emit an escape sequence that switches
the terminal emulator to Tektronix mode. Also, some of the Tektronix
control codes emitted by the <a href="Plotter.html">Plotter</a> will be
kermit-specific. There will be a limited amount of color support, which is
not normally the case (the 16 ansi.sys colors will be supported). The
<em>dotdotdashed</em> line style will be supported, which is also not
normally the case. After drawing graphics, the <a
href="Plotter.html">Plotter</a> will emit an escape sequence that returns
the emulator to VT100 mode. The key sequence <em>ALT minus</em> may be
employed manually within kermit to switch between the two modes.</p>
</dd><dt>TRANSPARENT_COLOR</dt>
<dd>
<p>(Default “none”.) Relevant only to GIF Plotters. If the value is a
recognized color name, that color, if it appears in the pseudo-GIF output
file, will be treated as transparent by most applications that display GIF
files. For information on what names are recognized, see section Specifying
Colors by Name. If <tt>TRANSPARENT_COLOR</tt> is set and an animated
pseudo-GIF file is produced, the <em>restore to background</em> disposal
method will be used for each image in the file. Otherwise, the
<em>unspecified</em> disposal method will be used.</p>
</dd><dt>USE_DOUBLE_BUFFERING</dt>
<dd>
<p>(Default “no”.) Relevant only to X Plotters and X Drawable Plotters. If the
value is “yes”, a double buffering scheme will be used when drawing
graphics.  Each frame of graphics, within a <tt>open</tt>…<tt>close</tt>
pair, will be written to an off-screen buffer rather than to the Plotter’s
display. When erase is invoked to end a frame, or when closepl is invoked,
the contents of the off-screen buffer will be copied to the Plotter’s
display, pixel by pixel. If successive frames differ only slightly, this
will create the illusion of smooth animation. Some X displays provide
special hardware support for double buffering. If this support is
available, the X <a href="Plotter.html">Plotter</a> will detect its
presence, and will draw graphics using the appropriate extension to the X11
protocol (either DBE or MBX). In this case the animation will be
significantly faster; on high-end graphics hardware, at least.</p>
</dd><dt>VANISH_ON_DELETE</dt>
<dd>
<p>(Default “no”.) Relevant only to X Plotters. If the value is “yes”, when a
<a href="Plotter.html">Plotter</a> is deleted, the window or windows that
it has popped up will vanish. Otherwise, each such window will remain on
the screen until it is removed by the user (by typing “q” in it, or by
clicking with a mouse).</p>
</dd><dt>XDRAWABLE_COLORMAP</dt>
<dd>
<p>(Default <tt>nil</tt>.) Relevant only to X Drawable Plotters.  If the value
is non-nil, it should be a Colormap *, a pointer to a colormap from which
colors should be allocated. nil indicates that the colormap to be used
should be the default colormap of the default screen of the X display.</p>
</dd><dt>XDRAWABLE_DISPLAY</dt>
<dd>
<p>(Default <tt>nil</tt>.) Relevant only to X Drawable Plotters.  The value
should be a Display *, a pointer to the X display with which the
drawable(s) to be drawn in are associated.</p>
</dd><dt>XDRAWABLE_DRAWABLE1, XDRAWABLE_DRAWABLE2</dt>
<dd>
<p>(Default <tt>nil</tt>.) Relevant only to X Drawable Plotters. If set, the
value of each of these parameters should be a Drawable *, a pointer to a
drawable to be drawn in. A <em>drawable</em> is either a window or a
pixmap. At the time an X Drawable <a href="Plotter.html">Plotter</a> is
created, at least one of the two parameters must be set. X Drawable
Plotters support simultaneous drawing in two drawables because it is often
useful to be able to draw graphics simultaneously in both an X window and
its background pixmap. If two drawables are specified, they must have the
same dimensions and depth, and be associated with the same screen of the X
display.</p>
</dd></dl>
          

          
          <div class="method-source-code"
            id="params-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 596</span>
def self.params(options = {})
  options.each do |k,v|
    <span class="ruby-constant">Rplot</span>.param(k.to_s.upcase, v.to_s)
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
    </div>
  
    <div id="public-instance-method-details" class="method-section section">
      <h3 class="section-header">Public Instance Methods</h3>

    
      <div id="alabel-method" class="method-detail ">
        <a name="method-i-alabel"></a>

        
        <div class="method-heading">
          <span class="method-name">alabel</span><span
            class="method-args">(horiz_justify, vert_justify, s)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>alabel</tt> takes three arguments <tt>horiz_justify</tt>,
<tt>vert_justify</tt>, and <tt>s</tt>, which specify an <em>adjusted
label</em>, i.e., a justified text string. The path under construction (if
any) is ended, and the string <tt>s</tt> is drawn according to the
specified justifications. If <tt>horiz_justify</tt> is equal to +"l"+,
+"c"+, or +"r"+, then the string will be drawn with left, center or right
justification, relative to the current graphics cursor position. If
<tt>vert_justify</tt> is equal to +"b"+, +"x"+, +"c"+, or +"t"+, then the
bottom, baseline, center or top of the string will be placed even with the
current graphics cursor position. The graphics cursor is moved to the right
end of the string if left justification is specified, and to the left end
if right justification is specified. The string may contain escape
sequences of various sorts, though it should not contain line feeds or
carriage returns.  In fact it should include only printable characters,
from the byte ranges 0x20...0x7e and 0xa0...0xff. The string may be plotted
at a nonzero angle, if textangle has been called.</p>
          

          
          <div class="method-source-code"
            id="alabel-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 771</span>
def alabel(horiz_justify, vert_justify, s)
  horiz_justify = horiz_justify.getbyte(0) if horiz_justify.class == <span class="ruby-constant">String</span>
  vert_justify = vert_justify.getbyte(0) if vert_justify.class == <span class="ruby-constant">String</span>
  super(horiz_justify, vert_justify, s.to_s)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="arc-method" class="method-detail ">
        <a name="method-i-arc"></a>

        
        <div class="method-heading">
          <span class="method-name">arc</span><span
            class="method-args">(xc, yc, x0, y0, x1, y1, options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>arc</tt> take six arguments specifying the beginning (x0, y0), end (x1,
y1), and center (xc, yc) of a circular arc. If the graphics cursor is at
(x0, y0) and a path is under construction, then the arc is added to the
path. Otherwise the current path (if any) is ended, and the arc begins a
new path. In all cases the graphics cursor is moved to (x1, y1). The
direction of the arc (clockwise or counterclockwise) is determined by the
convention that the arc, centered at (xc, yc), sweep through an angle of at
most 180 degrees. If the three points appear to be collinear, the direction
is taken to be counterclockwise. If (xc, yc) is not equidistant from (x0,
y0) and (x1, y1) as it should be, it is corrected by being moved to the
closest point on the perpendicular bisector of the line segment joining
(x0, y0) and (x1, y1). If <tt>:rel</tt> option is passed use
cursor-relative coordinates.</p>
          

          
          <div class="method-source-code"
            id="arc-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 791</span>
def arc(xc, yc, x0, y0, x1, y1, options = {})
  if options[:rel]
    farcrel(xc, yc, x0, y0, x1, y1)
  else
    farc(xc, yc, x0, y0, x1, y1)
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="bezier2-method" class="method-detail ">
        <a name="method-i-bezier2"></a>

        
        <div class="method-heading">
          <span class="method-name">bezier2</span><span
            class="method-args">(x0, y0, x1, y1, x2, y2, options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>bezier2</tt> take six arguments specifying the beginning p0=(x0, y0)
and end p2=(x2, y2) of a quadratic Bezier curve, and its intermediate
control point p1=(x1, y1). If the graphics cursor is at p0 and a path is
under construction, then the curve is added to the path. Otherwise the
current path (if any) is ended, and the curve begins a new path. In all
cases the graphics cursor is moved to p2. If <tt>:rel</tt> option is passed
use cursor-relative coordinates. The quadratic Bezier curve is tangent at
p0 to the line segment joining p0 to p1, and is tangent at p2 to the line
segment joining p1 to p2. So it fits snugly into a triangle with vertices
p0, p1, and p2. When using a PCL <a href="Plotter.html">Plotter</a> to draw
Bezier curves on a LaserJet III, you should set the parameter PCL_BEZIERS
to "no". That is because the LaserJet III, which was Hewlett--Packard's
first PCL 5 printer, does not recognize the Bezier instructions supported
by later PCL 5 printers.</p>
          

          
          <div class="method-source-code"
            id="bezier2-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 814</span>
def bezier2(x0, y0, x1, y1, x2, y2, options = {})
  if options[:rel]
    fbezier2rel(x0, y0, x1, y1, x2, y2)
  else
    fbezier2(x0, y0, x1, y1, x2, y2)
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="bezier3-method" class="method-detail ">
        <a name="method-i-bezier3"></a>

        
        <div class="method-heading">
          <span class="method-name">bezier3</span><span
            class="method-args">(x0, y0, x1, y1, x2, y2, x3, y3, options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>bezier3</tt> take eight arguments specifying the beginning p0=(x0, y0)
and end p3=(x3, y3) of a cubic Bezier curve, and its intermediate control
points p1=(x1, y1) and p2=(x2, y2). If the graphics cursor is at p0 and a
path is under construction, then the curve is added to the path. Otherwise
the current path (if any) is ended, and the curve begins a new path. In all
cases the graphics cursor is moved to p3. If <tt>:rel</tt> option is passed
use cursor-relative coordinates. The cubic Bezier curve is tangent at p0 to
the line segment joining p0 to p1, and is tangent at p3 to the line segment
joining p2 to p3. So it fits snugly into a quadrangle with vertices p0, p1,
p2, and p3. When using a PCL <a href="Plotter.html">Plotter</a> to draw
Bezier curves on a LaserJet III, you should set the parameter PCL_BEZIERS
to "no". That is because the LaserJet III, which was Hewlett--Packard's
first PCL 5 printer, does not recognize the Bezier instructions supported
by later PCL 5 printers.</p>
          

          
          <div class="method-source-code"
            id="bezier3-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 838</span>
def bezier3(x0, y0, x1, y1, x2, y2, x3, y3, options = {})
  if options[:rel]
    fbezier3rel(x0, y0, x1, y1, x2, y2, x3, y3)
  else
    fbezier3(x0, y0, x1, y1, x2, y2, x3, y3)
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="bgcolor-method" class="method-detail ">
        <a name="method-i-bgcolor"></a>

        
        <div class="method-heading">
          <span class="method-name">bgcolor</span><span
            class="method-args">(red_or_name, green = nil, blue = nil, options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Sets the background color for the Plotter’s graphics display, using a
48-bit RGB color model. The arguments red, green and blue specify the red,
green and blue intensities of the background color. Each is an integer in
the range 0x0000…0xffff, i.e., 0…65535. The choice (0, 0, 0) signifies
black, and the choice (65535, 65535, 65535) signifies white. bgcolor
affects only Plotters that produce bitmaps, i.e., X Plotters, X Drawable
Plotters, PNM Plotters, and GIF Plotters. Its effect is simple: the next
time the erase operation is invoked on such a <a
href="Plotter.html">Plotter</a>, its display will be filled with the
specified color.  If the first parameter is a string, it is considered as
color name. <tt>green</tt> and <tt>blue</tt> parameters may be
<tt>nil</tt>.  If <tt>:erase</tt> option is passed then call <tt>erase</tt>
too.</p>
          

          
          <div class="method-source-code"
            id="bgcolor-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 654</span>
def bgcolor(red_or_name, green = nil, blue = nil, options = {})
  if red_or_name.class == <span class="ruby-constant">Fixnum</span> &amp;&amp; green.class == <span class="ruby-constant">Fixnum</span> &amp;&amp; blue.class == <span class="ruby-constant">Fixnum</span>
    super(red_or_name, green, blue)
  else
    self.bgcolorname(red_or_name.to_s)
  end
  erase if options[:erase]
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="box-method" class="method-detail ">
        <a name="method-i-box"></a>

        
        <div class="method-heading">
          <span class="method-name">box</span><span
            class="method-args">(x1, y1, x2, y2, options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>box</tt> take four arguments specifying the lower left corner (x1, y1)
and upper right corner (x2, y2) of a <em>box</em>, or rectangle. The path
under construction (if any) is ended, and the box is drawn as a new path.
This path is also ended, and the graphics cursor is moved to the midpoint
of the box. If <tt>:rel</tt> option is passed use cursor-relative
coordinates.</p>
          

          
          <div class="method-source-code"
            id="box-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 852</span>
def box(x1, y1, x2, y2, options = {})
  if options[:rel]
    fboxrel(x1, y1, x2, y2)
  else
    fbox(x1, y1, x2, y2)
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="capmod-method" class="method-detail ">
        <a name="method-i-capmod"></a>

        
        <div class="method-heading">
          <span class="method-name">capmod</span><span
            class="method-args">(s)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>capmod</tt> sets the cap mode (i.e., cap style) for all paths
subsequently drawn on the graphics display. Recognized styles are
<em>butt</em> (the default), <em>round</em>, and <em>projecting</em>. The
three styles are visibly distinct only if the line thickness is fairly
large. Butt caps do not extend beyond the end of the path. The other two
kinds do, however. Round caps are filled semicircles, and projecting caps
are filled rectangular regions that extend a distance equal to half the
line width beyond the end of the path. PCL and HP-GL Plotters support a
fourth cap mode, <em>triangular</em>. Plotters other than PCL and HP-GL
Plotters treat <em>triangular</em> as equivalent to <em>round</em>. This
function has no effect on Tektronix Plotters. Also, it has no effect on
HP-GL Plotters if the parameter HPGL_VERSION is set to a value less than
"2" (the default).</p>
          

          
          <div class="method-source-code"
            id="capmod-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1057</span>
def capmod(s)
  super(s)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="circle-method" class="method-detail ">
        <a name="method-i-circle"></a>

        
        <div class="method-heading">
          <span class="method-name">circle</span><span
            class="method-args">(xc, yc, r, options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>circle</tt> take three arguments specifying the center (xc, yc) and
radius (r) of a circle. The path under construction (if any) is ended, and
the circle is drawn. The graphics cursor is moved to (xc, yc). If
<tt>:rel</tt> option is passed use cursor-relative coordinates.</p>
          

          
          <div class="method-source-code"
            id="circle-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 865</span>
def circle(xc, yc, r, options = {})
  if options[:rel]
    fcirclerel(xc, yc, r)
  else
    fcircle(xc, yc, r)
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="close-method" class="method-detail ">
        <a name="method-i-close"></a>

        
        <div class="method-heading">
          <span class="method-name">close</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>close</tt> closes a <a href="Plotter.html">Plotter</a>, i.e., ends a
page of graphics.</p>

<p><tt>ClosePlotterError</tt> exception will be raise if the <a
href="Plotter.html">Plotter</a> could not be close.</p>
          

          
          <div class="method-source-code"
            id="close-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 743</span>
def close
  super
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="color-method" class="method-detail ">
        <a name="method-i-color"></a>

        
        <div class="method-heading">
          <span class="method-name">color</span><span
            class="method-args">(red_or_name, green = nil, blue = nil)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>color</tt> is a convenience function. Calling <tt>color</tt> is
equivalent to calling both <tt>pencolor</tt> and <tt>fillcolor</tt>, to set
both the the pen color and fill color of all objects subsequently drawn on
the graphics display. Note that the physical fill color depends also on the
fill fraction, which is specified by calling <tt>filltype</tt>. If the
first parameter is a string, it is considered as color name. <tt>green</tt>
and <tt>blue</tt> parameters may be <tt>nil</tt>.</p>
          

          
          <div class="method-source-code"
            id="color-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1068</span>
def color(red_or_name, green = nil, blue = nil)
  if red_or_name.class == <span class="ruby-constant">Fixnum</span> &amp;&amp; green.class == <span class="ruby-constant">Fixnum</span> &amp;&amp; blue.class == <span class="ruby-constant">Fixnum</span>
    super(red_or_name, green, blue)
  else
    colorname(red_or_name.to_s)
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="concat-method" class="method-detail ">
        <a name="method-i-concat"></a>

        
        <div class="method-heading">
          <span class="method-name">concat</span><span
            class="method-args">(m0, m1, m2, m3, tx, ty)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Apply a Postscript-style transformation matrix, i.e., affine map, to the
user coordinate system. That is, apply the linear transformation defined by
the two-by-two matrix <tt>[m0 m1 m2 m3]</tt> to the user coordinate system,
and also translate by <tt>tx</tt> units in the x direction and <tt>ty</tt>
units in the y direction, relative to the former user coordinate system.
The following three functions (<tt>rotate</tt>, <tt>scale</tt>,
<tt>translate</tt>) are convenience functions that are special cases of
<tt>concat</tt>.</p>
          

          
          <div class="method-source-code"
            id="concat-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1392</span>
def concat(m0, m1, m2, m3, tx, ty)
  fconcat(m0, m1, m2, m3, tx, ty)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="cont-method" class="method-detail ">
        <a name="method-i-cont"></a>

        
        <div class="method-heading">
          <span class="method-name">cont</span><span
            class="method-args">(x, y, options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>cont</tt> take two arguments specifying the coordinates (x, y) of a
point. If a path is under construction, the line segment from the current
graphics cursor position to the point (x, y) is added to it. Otherwise the
line segment begins a new path. In all cases the graphics cursor is moved
to (x, y). If <tt>:rel</tt> option is passed use cursor-relative
coordinates.</p>
          

          
          <div class="method-source-code"
            id="cont-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 879</span>
def cont(x, y, options = {})
  if options[:rel]
    fcontrel(x, y)
  else
    fcont(x, y)
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="delete-method" class="method-detail ">
        <a name="method-i-delete"></a>

        
        <div class="method-heading">
          <span class="method-name">delete</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Delete the <a href="Plotter.html">Plotter</a>.</p>

<p><tt>DeletePlotterError</tt> exception will be raise if the <a
href="Plotter.html">Plotter</a> could not be delete.</p>
          

          
          <div class="method-source-code"
            id="delete-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 241</span>
def delete
  super
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="draw-method" class="method-detail ">
        <a name="method-i-draw"></a>

        
        <div class="method-heading">
          <span class="method-name">draw</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Wrap <a href="Plotter.html">Plotter</a> operations between <tt>open</tt>,
<tt>erase</tt> and <tt>delete</tt> methods.</p>
          

          
          <div class="method-source-code"
            id="draw-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 615</span>
def draw
  self.open
  self.erase
  yield
  self.delete
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="ellarc-method" class="method-detail ">
        <a name="method-i-ellarc"></a>

        
        <div class="method-heading">
          <span class="method-name">ellarc</span><span
            class="method-args">(xc, yc, x0, y0, x1, y1, options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>ellarc</tt> take six arguments specifying the three points pc=(xc,yc),
p0=(x0,y0), and p1=(x1,y1) that define a so-called quarter ellipse. This is
an elliptic arc from p0 to p1 with center pc. If the graphics cursor is at
point p0 and a path is under construction, the quarter-ellipse is added to
it. Otherwise the path under construction (if any) is ended, and the
quarter-ellipse begins a new path. In all cases the graphics cursor is
moved to p1. The quarter-ellipse is an affinely transformed version of a
quarter circle. It is drawn so as to have control points p0, p1, and
p0+p1-pc. This means that it is tangent at p0 to the line segment joining
p0 to p0+p1-pc, and is tangent at p1 to the line segment joining p1 to
p0+p1-pc. So it fits snugly into a triangle with these three control points
as vertices. Notice that the third control point is the reflection of pc
through the line joining p0 and p1. If <tt>:rel</tt> option is passed use
cursor-relative coordinates.</p>
          

          
          <div class="method-source-code"
            id="ellarc-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 903</span>
def ellarc(xc, yc, x0, y0, x1, y1, options = {})
  if options[:rel]
    fellarcrel(xc, yc, x0, y0, x1, y1)
  else
    fellarc(xc, yc, x0, y0, x1, y1)
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="ellipse-method" class="method-detail ">
        <a name="method-i-ellipse"></a>

        
        <div class="method-heading">
          <span class="method-name">ellipse</span><span
            class="method-args">(xc, yc, rx, ry, angle, options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>ellipse</tt> take five arguments specifying the center (xc, yc) of an
ellipse, the lengths of its semiaxes (rx and ry), and the inclination of
the first semiaxis in the counterclockwise direction from the x axis in the
user coordinate system. The path under construction (if any) is ended, and
the ellipse is drawn. The graphics cursor is moved to (xc, yc). If
<tt>:rel</tt> option is passed use cursor-relative coordinates.</p>
          

          
          <div class="method-source-code"
            id="ellipse-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 918</span>
def ellipse(xc, yc, rx, ry, angle, options = {})
  if options[:rel]
    fellipserel(xc, yc, rx, ry, angle)
  else
    fellipse(xc, yc, rx, ry, angle)
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="endpath-method" class="method-detail ">
        <a name="method-i-endpath"></a>

        
        <div class="method-heading">
          <span class="method-name">endpath</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>endpath</tt> terminates the path under construction, if any. A path is
constructed by one or more successive calls to <tt>cont</tt>,
<tt>line</tt>, <tt>arc</tt>, <tt>ellarc</tt>, <tt>bezier2</tt> and
<tt>bezier3</tt>. The path will also be terminated if any non-path object
is drawn, if any path-related drawing attribute is set, or if <tt>move</tt>
is invoked to set the cursor position. So <tt>endpath</tt> is almost
redundant. However, if a <a href="Plotter.html">Plotter</a> plots objects
in real time, calling <tt>endpath</tt> will ensure that a constructed path
is drawn on the graphics display without delay.</p>
          

          
          <div class="method-source-code"
            id="endpath-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 935</span>
def endpath()
  super
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="erase-method" class="method-detail ">
        <a name="method-i-erase"></a>

        
        <div class="method-heading">
          <span class="method-name">erase</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>erase</tt> begins the next frame of a multiframe page, by clearing all
previously plotted objects from the graphics display, and filling it with
the background color (if any). It is frequently useful to invoke erase at
the beginning of each page, i.e., immediately after invoking <tt>open</tt>.
That is because some Plotters are persistent, in the sense that objects
drawn within an <tt>open</tt>...<tt>close</tt> pair remain on the graphics
display even after a new page is begun by a subsequent invocation of
<tt>open</tt>. Currently, only X Drawable Plotters and Tektronix Plotters
are persistent. Future releases may support optional persistence for X
Plotters also. On X Plotters and X Drawable Plotters the effects of
invoking erase will be altogether different if the device driver parameter
<tt>USE_DOUBLE_BUFFERING</tt> is set to "yes". In this case, objects will
be written to an off-screen buffer rather than to the graphics display, and
invoking erase will (1) copy the contents of this buffer to the display,
and (2) erase the buffer by filling it with the background color. This
<em>double buffering</em> feature facilitates smooth animation.</p>
          

          
          <div class="method-source-code"
            id="erase-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 681</span>
def erase
  super
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="fillcolor-method" class="method-detail ">
        <a name="method-i-fillcolor"></a>

        
        <div class="method-heading">
          <span class="method-name">fillcolor</span><span
            class="method-args">(red_or_name, green = nil, blue = nil)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>fillcolor</tt> sets the fill color of all objects subsequently drawn on
the graphics display, using a 48-bit RGB color model. The arguments red,
green and blue specify the red, green and blue intensities of the fill
color. Each is an integer in the range 0x0000...0xffff, i.e., 0...65535.
The choice (0, 0, 0) signifies black, and the choice (65535, 65535, 65535)
signifies white. Note that the physical fill color depends also on the fill
fraction, which is specified by calling <tt>filltype</tt>. If the first
parameter is a string, it is considered as color name. <tt>green</tt> and
<tt>blue</tt> parameters may be <tt>nil</tt>.</p>
          

          
          <div class="method-source-code"
            id="fillcolor-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1086</span>
def fillcolor(red_or_name, green = nil, blue = nil)
  if red_or_name.class == <span class="ruby-constant">Fixnum</span> &amp;&amp; green.class == <span class="ruby-constant">Fixnum</span> &amp;&amp; blue.class == <span class="ruby-constant">Fixnum</span>
    super(red_or_name, green, blue)
  else
    fillcolorname(red_or_name.to_s)
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="fillmod-method" class="method-detail ">
        <a name="method-i-fillmod"></a>

        
        <div class="method-heading">
          <span class="method-name">fillmod</span><span
            class="method-args">(s)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>fillmod</tt> sets the fill mode, i.e., fill rule, for all objects
subsequently drawn on the graphics display. The fill rule affects only
filled, self-intersecting paths: it determines which points are
<em>inside</em>. Two rules are supported: <em>even-odd</em> (the default
for all Plotters), and <em>nonzero-winding</em>. For the distinction, see
the Postscript Language Reference Manual. <em>alternate</em> is an alias
for <em>even-odd</em> and <em>winding</em> is an alias for
<em>nonzero-winding</em>. Fig Plotters do not support the
<em>nonzero-winding</em> fill rule, because xfig itself does not support
it. Also, HPGL Plotters do not support it if HPGL_VERSION is set to a value
less than "2" (the default). The LaserJet III, which was Hewlett--Packard's
first PCL 5 printer, did not support the <em>nonzero-winding</em> fill
rule. However, all later PCL 5 printers from Hewlett--Packard support it.</p>
          

          
          <div class="method-source-code"
            id="fillmod-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1108</span>
def fillmod(s)
  super(s)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="filltype-method" class="method-detail ">
        <a name="method-i-filltype"></a>

        
        <div class="method-heading">
          <span class="method-name">filltype</span><span
            class="method-args">(level)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>filltype</tt> sets the fill fraction for all subsequently drawn
objects. A value of 0 for level indicates that objects should be unfilled,
or transparent. This is the default. A value in the range 0x0001...0xffff,
i.e., 1...65535, indicates that objects should be filled. A value of 1
signifies 100% filling (the fill color will simply be the color specified
by calling fillcolor or fillcolorname). If <tt>level=0xffff</tt>, the fill
color will be white. Values between 0x0001 and 0xffff are interpreted as
specifying a desaturation, or gray level. For example, 0x8000 specifies 50%
filling (the fill color will be intermediate between the color specified by
calling fillcolor or fillcolorname, and white). Tektronix Plotters do not
support filling, and HP-GL Plotters support filling of arbitrary paths only
if the parameter HPGL_VERSION is equal to "1.5" or "2" (the default). (If
the version is "1" then only circles and rectangles aligned with the
coordinate axes may be filled.) Opaque filling, including white filling, is
supported only if the parameter HPGL_VERSION is "2" and the parameter
HPGL_OPAQUE_MODE is "yes" (the default).</p>
          

          
          <div class="method-source-code"
            id="filltype-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1130</span>
def filltype(level)
  super(level)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="flush-method" class="method-detail ">
        <a name="method-i-flush"></a>

        
        <div class="method-heading">
          <span class="method-name">flush</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>flush</tt> flushes (i.e., pushes onward) all plotting commands to the
display device. This is useful only if the currently selected <a
href="Plotter.html">Plotter</a> does real-time plotting, since it may be
used to ensure that all previously plotted objects have been sent to the
display and are visible to the user.  It has no effect on Plotters that do
not do real-time plotting.</p>
          

          
          <div class="method-source-code"
            id="flush-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 735</span>
def flush
  super
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="fmiterlimit-method" class="method-detail ">
        <a name="method-i-fmiterlimit"></a>

        
        <div class="method-heading">
          <span class="method-name">fmiterlimit</span><span
            class="method-args">(limit)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>fmiterlimit</tt> sets the miter limit for all paths subsequently drawn
on the graphics display. The miter limit controls the treatment of corners,
if the join mode is set to <em>miter</em> (the default). At a join point of
a path, the <em>miter length</em> is defined to be the distance between the
inner corner and the outer corner. The miter limit is the maximum value
that will be tolerated for the miter length divided by the line thickness.
If this value is exceeded, the miter will be cut off: the <em>bevel</em>
join mode will be used instead. Examples of typical values for limit are
10.43 (the default, which cuts off miters if the join angle is less than 11
degrees), 2.0 (the same, for 60 degrees), and 1.414 (the same, for 90
degrees). In general, the miter limit is the cosecant of one-half the
minimum angle for mitered joins. The minimum meaningful value for limit is
1.0, which converts all mitered joins to beveled joins, irrespective of
join angle. Specifying a value less than 1.0 resets the limit to the
default. This function has no effect on X Drawable Plotters or X Plotters,
since the X Window System miter limit, which is also 10.43, cannot be
altered. It also has no effect on Tektronix Plotters or Fig Plotters, or on
HP-GL Plotters if the parameter HPGL_VERSION is set to a value less than
"2" (the default).</p>
          

          
          <div class="method-source-code"
            id="fmiterlimit-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1155</span>
def fmiterlimit(limit)
  super(limit)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="fontname-method" class="method-detail ">
        <a name="method-i-fontname"></a>

        
        <div class="method-heading">
          <span class="method-name">fontname</span><span
            class="method-args">(font_name)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>fontname</tt> take a single case-insensitive string argument,
<tt>font_name</tt>, specifying the name of the font to be used for all text
strings subsequently drawn on the graphics display. (The font for plotting
strings is fully specified by calling <tt>fontname</tt>, <tt>fontsize</tt>,
and <tt>textangle</tt>.) The size of the font in user coordinates is
returned. The default font name depends on the type of <a
href="Plotter.html">Plotter</a>. It is "Helvetica" for all Plotters except
PNM, GIF, HP-GL, Tektronix and Metafile Plotters, for which it is
"HersheySerif". If the argument <tt>font_name</tt> is <tt>nil</tt> or the
empty string, or the font is not available, the default font name will be
used. Which fonts are available also depends on the type of <a
href="Plotter.html">Plotter</a>.</p>
          

          
          <div class="method-source-code"
            id="fontname-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1171</span>
def fontname(font_name)
  ffontname(font_name)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="fontsize-method" class="method-detail ">
        <a name="method-i-fontsize"></a>

        
        <div class="method-heading">
          <span class="method-name">fontsize</span><span
            class="method-args">(size)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>fontsize</tt> take a single argument, interpreted as the size, in the
user coordinate system, of the font to be used for all text strings
subsequently drawn on the graphics display. (The font for plotting strings
is fully specified by calling fontname, fontsize, and textangle.) The size
of the font in user coordinates is returned. A negative value for size sets
the size to the default, which depends on the type of <a
href="Plotter.html">Plotter</a>. Typically, the default font size is 1/50
times the size (i.e., minimum dimension) of the display.</p>
          

          
          <div class="method-source-code"
            id="fontsize-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1184</span>
def fontsize(size)
  ffontsize(size)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="havecap-method" class="method-detail ">
        <a name="method-i-havecap"></a>

        
        <div class="method-heading">
          <span class="method-name">havecap</span><span
            class="method-args">(s)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>havecap</tt> tests whether or not a <a href="Plotter.html">Plotter</a>,
which need not be open, has a specified capability. The return value is 0,
1, or 2, signifying no/yes/maybe. For unrecognized capabilities the return
value is zero.  Recognized capabilities include: [WIDE_LINES] The ability
to draw lines with a non-default thickness [DASH_ARRAY] The ability to draw
in arbitrary dashing styles, as requested by the linedash function)
[SETTABLE_BACKGROUND] The ability to set the color of the background
[SOLID_FILL] The "HERSHEY_FONTS", "PS_FONTS", "PCL_FONTS", and
"STICK_FONTS" capabilities indicate whether or not fonts of a particular
class are supported. All Plotters except Tektronix Plotters have the
"SOLID_FILL" capability, meaning they can fill paths with solid color. Each
such <a href="Plotter.html">Plotter</a> has at least one of the
"EVEN_ODD_FILL" and "NONZERO_WINDING_NUMBER_FILL" capabilities. These
indicate the supported rules for determining the <em>inside</em> of a path.
The <em>maybe</em> value is returned for most capabilities by Metafile
Plotters, which do no drawing themselves. The output of a Metafile <a
href="Plotter.html">Plotter</a> must be translated to another format, or
displayed, by invoking plot.</p>
          

          
          <div class="method-source-code"
            id="havecap-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 725</span>
def havecap(s)
  super(s.to_s)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="joinmod-method" class="method-detail ">
        <a name="method-i-joinmod"></a>

        
        <div class="method-heading">
          <span class="method-name">joinmod</span><span
            class="method-args">(s)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>joinmod</tt> sets the join mode (i.e., join style) for all paths
subsequently drawn on the graphics display. Recognized styles are
<em>miter</em> (the default), <em>round</em>, and <em>bevel</em>. The three
styles are visibly distinct only if the line thickness is fairly large.
Mitered joins are sharp, rounded joins are round, and beveled joins are
squared off. However, unusually sharp joins are never mitered: instead,
they are beveled. The angle at which beveling replaces mitering may be
specified by calling fmiterlimit. PCL and HP-GL Plotters support a fourth
join mode, <em>triangular</em>. Plotters other than PCL and HP-GL Plotters
treat <em>triangular</em> as equivalent to <em>round</em>. This function
has no effect on Tektronix Plotters. Also, it has no effect on HP-GL
Plotters if the parameter HPGL_VERSION is set to a value less than "2" (the
default).</p>
          

          
          <div class="method-source-code"
            id="joinmod-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1202</span>
def joinmod(s)
  super(s)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="label-method" class="method-detail ">
        <a name="method-i-label"></a>

        
        <div class="method-heading">
          <span class="method-name">label</span><span
            class="method-args">(s)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>label</tt> takes a single string argument <tt>s</tt> and draws the text
contained in <tt>s</tt> at the current graphics cursor position. The text
is left justified, and the graphics cursor is moved to the right end of the
string. This function is provided for backward compatibility; the function
call <tt>label(s)</tt> is equivalent to <tt>alabel('l', 'x', s)</tt>.</p>
          

          
          <div class="method-source-code"
            id="label-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 945</span>
def label(s)
  super(s)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="labelwidth-method" class="method-detail ">
        <a name="method-i-labelwidth"></a>

        
        <div class="method-heading">
          <span class="method-name">labelwidth</span><span
            class="method-args">(s)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>labelwidth</tt> compute and return the width of a string in the current
font, in the user coordinate system. The string is not plotted.</p>
          

          
          <div class="method-source-code"
            id="labelwidth-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 952</span>
def labelwidth(s)
  flabelwidth(s)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="line-method" class="method-detail ">
        <a name="method-i-line"></a>

        
        <div class="method-heading">
          <span class="method-name">line</span><span
            class="method-args">(x1, y1, x2, y2, options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>line</tt> take four arguments specifying the start point (x1, y1) and
end point (x2, y2) of a line segment. If the graphics cursor is at (x1, y1)
and a path is under construction, the line segment is added to it.
Otherwise the path under construction (if any) is ended, and the line
segment begins a new path. In all cases the graphics cursor is moved to
(x2, y2). If <tt>:rel</tt> option is passed use cursor-relative
coordinates.</p>
          

          
          <div class="method-source-code"
            id="line-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 963</span>
def line(x1, y1, x2, y2, options = {})
  if options[:rel]
    flinerel(x1, y1, x2, y2)
  else
    fline(x1, y1, x2, y2)
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="linedash-method" class="method-detail ">
        <a name="method-i-linedash"></a>

        
        <div class="method-heading">
          <span class="method-name">linedash</span><span
            class="method-args">(dashes, offset)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>linedash</tt> set the line style for all paths, circles, and ellipses
subsequently drawn on the graphics display. They provide much finer control
of dash patterns than the <tt>linemod</tt> function (see below) provides.
Dashes should be an array of length <tt>n</tt>. Its elements, which should
be positive, are interpreted as distances in the user coordinate system.
Along any path, circle, or ellipse, the elements <a
href="http://n-1">dashes[0]...dashes</a> alternately specify the length of
a dash and the length of a gap between dashes. When the end of the array is
reached, the reading of the array wraps around to the beginning. If the
array is empty, i.e., n equals zero, there is no dashing: the drawn line is
solid. The offset argument specifies the <em>phase</em> of the dash pattern
relative to the start of the path. It is interpreted as the distance into
the dash pattern at which the dashing should begin. For example, if offset
equals zero then the path will begin with a dash, of length dashes[0] in
user space. If offset equals dashes[0] then the path will begin with a gap
of length dashes[1], and so forth. offset is allowed to be negative. Not
all Plotters fully support linedash and flinedash. HP-GL and PCL Plotters
cannot dash with a nonzero offset, and in the dash patterns used by X and X
Drawable Plotters, each dash and each gap has a maximum length of 255
pixels. linedash and flinedash have no effect on Tektronix and Fig
Plotters, and they have no effect on HP-GL Plotters for which the parameter
HPGL_VERSION is less than "2" (the default; see section Device driver
parameters). Warning: If the map from the user coordinate system to the
device coordinate system is not uniform, each dash in a dashed path should
ideally be drawn on the graphics display with a length that depends on its
direction. But currently, only Postscript Plotters do this. Other Plotters
always draw any specified dash with the same length, irrespective of its
direction. The length that is used is the minimum length, in the device
coordinate system, that can correspond to the specified dash length in the
user coordinate system.</p>
          

          
          <div class="method-source-code"
            id="linedash-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1239</span>
def linedash(dashes, offset)
  flinedash(dashes.size, dashes, offset)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="linemod-method" class="method-detail ">
        <a name="method-i-linemod"></a>

        
        <div class="method-heading">
          <span class="method-name">linemod</span><span
            class="method-args">(s)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>linemod</tt> sets the line style for all paths, circles, and ellipses
subsequently drawn on the graphics display. The supported line styles are
<em>solid</em>, <em>dotted</em>, <em>dotdashed</em>, <em>shortdashed</em>,
<em>longdashed</em>, <em>dotdotdashed</em>, <em>dotdotdotdashed</em>, and
<em>disconnected</em>. The first seven correspond to the following dash
patterns:</p>

<pre>&quot;solid&quot;             --------------------------------
&quot;dotted&quot;            -   -   -   -   -   -   -   -   
&quot;dotdashed&quot;         ----   -   ----   -   ----   -
&quot;shortdashed&quot;       ----    ----    ----    ----    
&quot;longdashed&quot;        -------    -------    -------    
&quot;dotdotdashed&quot;      ----   -   -   ----   -   -
&quot;dotdotdotdashed&quot;   ----   -   -   -   ----   -   -   -</pre>

<p>In the preceding patterns, each hyphen stands for one line thickness. This
is the case for sufficiently thick lines, at least. So for sufficiently
thick lines, the distance over which a dash pattern repeats is scaled
proportionately to the line thickness. The <em>disconnected</em> line style
is special. A <em>disconnected</em> path is rendered as a set of filled
circles, each of which has diameter equal to the nominal line thickness.
One of these circles is centered on each of the juncture points of the path
(i.e., the endpoints of the line segments or arcs from which it is
constructed). Circles and ellipses with <em>disconnected</em> line style
are invisible. Disconnected paths, circles, and ellipses are not filled.
All line styles are supported by all Plotters, with the following
exceptions. HP-GL Plotters do not support the <em>dotdotdotdashed</em>
style unless the parameter HPGL_VERSION is set to “2” (the default).
Tektronix Plotters do not support the <em>dotdotdotdashed</em> style, and
do not support the <em>dotdotdashed</em> style unless the parameter TERM is
set to <em>kermit</em>.</p>
          

          
          <div class="method-source-code"
            id="linemod-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1275</span>
def linemod(s)
  super(s)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="linewidth-method" class="method-detail ">
        <a name="method-i-linewidth"></a>

        
        <div class="method-heading">
          <span class="method-name">linewidth</span><span
            class="method-args">(size)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>linewidth</tt> set the thickness, in the user coordinate system, of all
paths, circles, and ellipses subsequently drawn on the graphics display. A
negative value resets the thickness to the default. The default thickness
depends on the type of <a href="Plotter.html">Plotter</a>. For most
Plotters, it is 1/850 times the size (i.e., minimum dimension) of the
display. But for Plotters that produce bitmaps, i.e., X Plotters, X
Drawable Plotters, PNM Plotters, and GIF Plotters, it is zero. By
convention, a zero-thickness line is the thinnest line that can be drawn.
However, the drawing editors idraw and xfig treat zero-thickness lines as
invisible. So when producing editable graphics with a Postscript or Fig <a
href="Plotter.html">Plotter</a>, using a zero line thickness may not be
desirable. Tektronix Plotters do not support drawing with other than a
default thickness, and HP-GL Plotters do not support doing so if the
parameter HPGL_VERSION is set to a value less than "2" (the default; see
section Device driver parameters). <b>Warning</b>: If the map from the user
coordinate system to the device coordinate system is not uniform, each line
segment in a polygonal path should ideally be drawn on the graphics display
with a thickness that depends on its direction. But currently, only
Postscript Plotters do this. Other Plotters draw all line segments in a
path with the same thickness. The thickness that is used is the minimum
thickness, in the device coordinate system, that can correspond to the
thickness of the path in the user coordinate system.</p>
          

          
          <div class="method-source-code"
            id="linewidth-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1303</span>
def linewidth(size)
  flinewidth(size)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="marker-method" class="method-detail ">
        <a name="method-i-marker"></a>

        
        <div class="method-heading">
          <span class="method-name">marker</span><span
            class="method-args">(x, y, type, size, options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>marker</tt> take four arguments specifying the location (x,y) of a
marker symbol, its type, and its size in user coordinates. The path under
construction (if any) is ended, and the marker symbol is plotted. The
graphics cursor is moved to (x,y). If <tt>:rel</tt> option is passed use
cursor-relative coordinates for the position (x,y). Marker symbol types 0
through 31 are taken from a standard set, and marker symbol types 32 and
above are interpreted as the index of a character in the current text font.
These are the symbols:</p>
<ol><li>
<p>dot</p>
</li><li>
<p>plus (+)</p>
</li><li>
<p>asterisk (*)</p>
</li><li>
<p>circle</p>
</li><li>
<p>cross</p>
</li><li>
<p>square</p>
</li><li>
<p>triangle</p>
</li><li>
<p>diamond</p>
</li><li>
<p>star</p>
</li><li>
<p>inverted triangle</p>
</li><li>
<p>starburst</p>
</li><li>
<p>fancy plus</p>
</li><li>
<p>fancy cross</p>
</li><li>
<p>fancy square</p>
</li><li>
<p>fancy diamond</p>
</li><li>
<p>filled circle</p>
</li><li>
<p>filled square</p>
</li><li>
<p>filled triangle</p>
</li><li>
<p>filled diamond</p>
</li><li>
<p>filled inverted triangle</p>
</li><li>
<p>filled fancy square</p>
</li><li>
<p>filled fancy diamond</p>
</li><li>
<p>half filled circle</p>
</li><li>
<p>half filled square</p>
</li><li>
<p>half filled triangle</p>
</li><li>
<p>half filled diamond</p>
</li><li>
<p>half filled inverted triangle</p>
</li><li>
<p>half filled fancy square</p>
</li><li>
<p>half filled fancy diamond</p>
</li><li>
<p>octagon</p>
</li><li>
<p>filled octagon</p>
</li></ol>

<p>The interpretation of marker symbols 1 through 5 is the same as in the well
known GKS (Graphical Kernel System). Symbols 32 and up are interpreted as
characters in a certain text font.</p>
          

          
          <div class="method-source-code"
            id="marker-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1014</span>
def marker(x, y, type, size, options = {})
  if options[:rel]
    fmarkerrel(x, y, type, size)
  else
    fmarker(x, y, type, size)
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="move-method" class="method-detail ">
        <a name="method-i-move"></a>

        
        <div class="method-heading">
          <span class="method-name">move</span><span
            class="method-args">(x, y, options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>move</tt> take two arguments specifying the coordinates (x, y) of a
point to which the graphics cursor should be moved. The path under
construction (if any) is ended, and the graphics cursor is moved to (x, y).
This is equivalent to lifting the pen on a plotter and moving it to a new
position, without drawing any line. If <tt>:rel</tt> option is passed use
cursor-relative coordinates.</p>
          

          
          <div class="method-source-code"
            id="move-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1313</span>
def move(x, y, options = {})
  if options[:rel]
    fmoverel(x, y)
  else
    fmove(x, y)
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="open-method" class="method-detail ">
        <a name="method-i-open"></a>

        
        <div class="method-heading">
          <span class="method-name">open</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Open a <a href="Plotter.html">Plotter</a>, i.e., begins a page of graphics.
This resets the Plotter’s drawing attributes to their default values. A
negative return value indicates the <a href="Plotter.html">Plotter</a>
could not be opened. Currently, an X <a href="Plotter.html">Plotter</a>
pops up a new window on an X Window System display for each page of
graphics, i.e., with each invocation of <tt>open</tt>. Future releases may
support window re-use.</p>

<p><tt>OpenPlotterError</tt> exception will be raise if the <a
href="Plotter.html">Plotter</a> could not be open.</p>
          

          
          <div class="method-source-code"
            id="open-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 637</span>
def open
  super
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="pencolor-method" class="method-detail ">
        <a name="method-i-pencolor"></a>

        
        <div class="method-heading">
          <span class="method-name">pencolor</span><span
            class="method-args">(red_or_name, green = nil, blue = nil)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>pencolor</tt> sets the pen color of all objects subsequently drawn on
the graphics display, using a 48-bit RGB color model. The arguments red,
green and blue specify the red, green and blue intensities of the pen
color. Each is an integer in the range 0x0000...0xffff, i.e., 0...65535.
The choice (0, 0, 0) signifies black, and the choice (65535, 65535, 65535)
signifies white. HP-GL Plotters support drawing with a white pen only if
the value of the parameter HPGL_VERSION is "2" (the default), and the value
of the parameter HPGL_OPAQUE_MODE is "yes" (the default). If the first
parameter is a string, it is considered as color name. <tt>green</tt> and
<tt>blue</tt> parameters may be <tt>nil</tt>.</p>
          

          
          <div class="method-source-code"
            id="pencolor-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1332</span>
def pencolor(red_or_name, green = nil, blue = nil)
  if red_or_name.class == <span class="ruby-constant">Fixnum</span> &amp;&amp; green.class == <span class="ruby-constant">Fixnum</span> &amp;&amp; blue.class == <span class="ruby-constant">Fixnum</span>
    super(red_or_name, green, blue)
  else
    pencolorname(red_or_name.to_s)
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="point-method" class="method-detail ">
        <a name="method-i-point"></a>

        
        <div class="method-heading">
          <span class="method-name">point</span><span
            class="method-args">(x, y, options = {})</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>point</tt> take two arguments specifying the coordinates (x, y) of a
point. The path under construction (if any) is ended, and the point is
plotted. (Plotters that produce bitmaps draw points as single pixels. Other
Plotters draw them as small solid circles, usually the smallest that can be
plotted.) The graphics cursor is moved to (x, y). If <tt>:rel</tt> option
is passed use cursor-relative coordinates.</p>
          

          
          <div class="method-source-code"
            id="point-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1029</span>
def point(x, y, options = {})
  if options[:rel]
    fpointrel(x, y)
  else
    fpoint(x, y)
  end
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="restorestate-method" class="method-detail ">
        <a name="method-i-restorestate"></a>

        
        <div class="method-heading">
          <span class="method-name">restorestate</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>restorestate</tt> pops the current graphics context off the stack of
drawing states. The graphics context consists largely of libplot's drawing
attributes, which are set by the attribute functions documented in this
doc. So popping off the graphics context restores the drawing attributes to
values they previously had. A path under construction is regarded as part
of the graphics context. For this reason, calling <tt>restorestate</tt>
automatically calls <tt>endpath</tt> to terminate the path under
construction, if any. All graphics contexts on the stack are popped off
when <tt>close</tt> is called, as if <tt>restorestate</tt> had been called
repeatedly.</p>
          

          
          <div class="method-source-code"
            id="restorestate-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1351</span>
def restorestate()
  super
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="rotate-method" class="method-detail ">
        <a name="method-i-rotate"></a>

        
        <div class="method-heading">
          <span class="method-name">rotate</span><span
            class="method-args">(theta)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Rotate the user coordinate system axes about their origin by <tt>theta</tt>
degrees, with respect to their former orientation. The position of the user
coordinate origin and the size of the x and y units remain unchanged.</p>
          

          
          <div class="method-source-code"
            id="rotate-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1400</span>
def rotate(theta)
  frotate(theta)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="savestate-method" class="method-detail ">
        <a name="method-i-savestate"></a>

        
        <div class="method-heading">
          <span class="method-name">savestate</span><span
            class="method-args">()</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>savestate</tt> pushes the current graphics context onto the stack of
drawing states. The graphics context consists largely of libplot's drawing
attributes, which are set by the attribute functions documented in this
doc. A path under construction, if any, is regarded as part of the graphics
context. That is because paths may be drawn incrementally, one line segment
or arc at a time. When a graphics context is returned to, the path under
construction may be continued.</p>
          

          
          <div class="method-source-code"
            id="savestate-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1363</span>
def savestate()
  super
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="scale-method" class="method-detail ">
        <a name="method-i-scale"></a>

        
        <div class="method-heading">
          <span class="method-name">scale</span><span
            class="method-args">(sx, sy)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Make the x and y units in the user coordinate system be the size of
<tt>sx</tt> and <tt>sy</tt> units in the former user coordinate system. The
position of the user coordinate origin and the orientation of the
coordinate axes are unchanged.</p>
          

          
          <div class="method-source-code"
            id="scale-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1408</span>
def scale(sx, sy)
  fscale(sx, sy)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="space-method" class="method-detail ">
        <a name="method-i-space"></a>

        
        <div class="method-heading">
          <span class="method-name">space</span><span
            class="method-args">(x0, y0, x1, y1)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>space</tt> take two pairs of arguments, specifying the positions of the
lower left corner and upper right corner of the graphics display, in user
coordinates. In other words, calling <tt>space</tt> sets the affine
transformation from user coordinates to device coordinates. One of these
operations must be performed at the beginning of each page of graphics,
i.e., immediately after <tt>open</tt> is invoked. Default is 0,0,1,1.</p>
          

          
          <div class="method-source-code"
            id="space-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 692</span>
def space(x0, y0, x1, y1)
  fspace(x0.to_f, y0.to_f, x1.to_f, y1.to_f)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="space2-method" class="method-detail ">
        <a name="method-i-space2"></a>

        
        <div class="method-heading">
          <span class="method-name">space2</span><span
            class="method-args">(x0, y0, x1, y1, x2, y2)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>space2</tt> are extended versions of <tt>space</tt>, and may be used
instead. Their arguments are the three defining vertices of an <em>affine
window</em> (a drawing parallelogram), in user coordinates. The specified
vertices are the lower left, the lower right, and the upper left. This
window will be mapped affinely onto the graphics display.</p>
          

          
          <div class="method-source-code"
            id="space2-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 702</span>
def space2(x0, y0, x1, y1, x2, y2)
  fspace2(x0.to_f, y0.to_f, x1.to_f, y1.to_f, x2.to_f, y2.to_f)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="textangle-method" class="method-detail ">
        <a name="method-i-textangle"></a>

        
        <div class="method-heading">
          <span class="method-name">textangle</span><span
            class="method-args">(angle)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p><tt>textangle</tt> take one argument, which specifies the <tt>angle</tt> in
degrees counterclockwise from the x (horizontal) axis in the user
coordinate system, for text strings subsequently drawn on the graphics
display. The default angle is zero. (The font for plotting strings is fully
specified by calling <tt>fontname</tt>, <tt>fontsize</tt>, and
<tt>textangle</tt>.) The size of the font for plotting strings, in user
coordinates, is returned.</p>
          

          
          <div class="method-source-code"
            id="textangle-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1374</span>
def textangle(angle)
  ftextangle(angle)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="translate-method" class="method-detail ">
        <a name="method-i-translate"></a>

        
        <div class="method-heading">
          <span class="method-name">translate</span><span
            class="method-args">(tx, ty)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Move the origin of the user coordinate system by <tt>tx</tt> units in the x
direction and <tt>ty</tt> units in the y direction, relative to the former
user coordinate system. The size of the x and y units and the orientation
of the coordinate axes are unchanged.</p>
          

          
          <div class="method-source-code"
            id="translate-source">
<pre>
<span class="ruby-comment"># File lib/rplot.rb, line 1416</span>
def translate(tx, ty)
  ftranslate(tx, ty)
end</pre>
          </div>
          
        </div>

        

        
      </div>

    
    </div>
  

  </div>

  <div id="validator-badges">
    <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
    <p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
      Rdoc Generator</a> 2</small>.</p>
  </div>

</body>
</html>

